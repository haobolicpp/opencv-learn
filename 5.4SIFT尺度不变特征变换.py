import cv2 as cv
import numpy as np
import math
from matplotlib import pyplot as plt

## 有如下功能：# 参考 https://max.book118.com/html/2017/0930/135243849.shtm https://www.cnblogs.com/Alliswell-WP/p/SIFT.html https://blog.csdn.net/u010440456/article/details/81483145
# 哈里斯角点检测器对于旋转的角，还能够检测出来，但对于缩放的角可能就检测不出来了。比如教程中带有弧线的拐角，由于哈里斯角检测的窗口大小限制，没法
#   用同样的窗口检测出一个放大了的角点。
# SIFT尺度不变对于下面情况，可以很好的找到特征点：
#   --目标旋转、缩放、平移
#   --图像仿射变换、投影变换
#   --光照影响
#   --杂物及噪声
# SIFT通过不同尺度空间查找特征点，来进行特征点匹配查找目标。
# 该算法是有专利限制的，所以需安装opencv的contrib模块。

# 【三大步骤】
#1、提取关键点
#2、对关键点附加详细的信息（局部特征）描述器
#3、进行两方特征点亮亮比较找出相互匹配的若干特征点，也就建立了物体间的对应关系。

# 1、【什么是关键点】
# 是一些十分突出的点，不会因光照条件的改变而消失，比如角点、边缘点、暗区域的亮点以及亮区域的暗点。
# 就是在不同尺度空间检测出具有方向信息得局部极值点。
# 三个特征：尺度、方向、大小

# 2、【什么是尺度空间】
# 尺度空间：各尺度图像的模糊程度逐渐变大，尺度越大图像越模糊，（类似人眼和目标距离远近的模糊）。L(x,y,σ) = G(x,y,σ)*I(x,y)是高斯函数与图像像素的卷积。
# 此处通过计算高斯金字塔，对图像进行降采样，构成多组图像(octave)，同时每一组图像还会用不同sigma的高斯核进行分层(interval)模糊
# 在高斯函数中，方差σ（sigma）有这样的特性：
#   --随着sigma的增大，整个高斯函数的尖峰逐渐减小，整体也变的更加平缓，则对图像的平滑效果越来越明显，即尺度越大。（https://blog.csdn.net/qinglongzhan/article/details/82348153）
#   --【性质】对图像先后做sigma1和sigma2的高斯处理，等同于做一次sqrt(sigma1*sigma1+sigma2*sigma2)的高斯滤波,即sigma0^2 = sigma1^2+sigma2^2
#   --这里sigma在同一组中的不同的层取值是这样的：sigma(s) = sigma0 * 2^(s/S)，这里s为一组内的第几层，S为当前组的层数(3~5)
#   --sigma在组之间取值是这样的：2倍的关系。最终的公式是σ(o,s) = σ0 * 2^(o+s/S),o为第几组
# 高斯金字塔组数：octave num = log2(min(w,h)) - 3

# 3、【关键点检测--LOG】Laplacion of Gaussian
# 是对高斯函数进行拉普拉斯计算，即分别对x和y进行二次偏导，再求和。

# 【关键点检测--DOG】Difference of Gaussian
# DOG(X,Y,sigma1, sigma2) = G(x,y,sigma1)-G(x,y,sigma2) （算法过程略）即相邻尺度高斯图像做差，即对同一组内的不同层两两做差
# 可以通过DOG来构建高斯差分金字塔。
# 关键点的初步探查 ： 在每组中的DOG差分金字塔图像中，对每个像素进行上下两层、同层一共26个点进行比较，看是否是极值。
# 在高斯差分图像上可以看出像素的变化，如果没有变化也就没有特征，特征必须是变化多的点。DOG图像描绘的是图像轮廓。

# 4、【关键点的精确定位】
# 上面计算的关键点，是离散的像素点，需要精确确定关键点位置，同时去除低对比度和不稳定的边缘关键点，提升匹配能力和抗噪声能力。
# [泰勒展开]可以在某点x0用泰勒展开式来描述原函数，当泰勒展开的级数项比较少时，离x0点近的x计算出来的y比较准确，远的x计算的不准，除非增加级数项。
# [泰勒展开求极值]文章中对展开的泰勒级数求导并等于0来求极值，可反复迭代对关键点更精确的定位。

# 5、【消除边缘效应】一个定义不好的高斯差分算子的极值在横跨边缘的地方有较大的主曲率，而在垂直边缘的方向有较小的主曲率。DOG算子会产生较强的边缘响应，需要剔除不稳定的边缘响应点。
# 主曲率可由该点通过二维海森矩阵H[[Dxx,Dxy][Dxy,Dyy]]得到，设特征值α、β，且α=rβ，H的特征值α和β代表x和y方向的梯度（求解过程参考线性代数及应用，讲的比较容易理解，此处不用计算，只计算比值）;
# Tr(H) = Dxx + Dyy = α+β （为何？TODO）
# Det(H) = Dxx*Dyy-Dxy*Dxy = α*β  行列式 （为何？TODO）
# 则Tr(H)^2/Det(H) = (r+1)*(r+1)/r，
# 两个特征值的比值越大，即在某一个方向的梯度值越大，而在另一个方向的梯度值越小，而边缘恰恰就是这种情况。所以为了剔除边缘响应点，需要让该比值小于一定的阈值，因此，为了检测主曲率是否在某域值r下，只需检测
# 取r=10,在Tr(H)^2/Det(H) < (r+1)*(r+1)/r，该关键点被保留！

# 6、【关键点方向分配】为了使描述符具有旋转不变性，需要利用图像局部特征，给每个关键点分配一个方向。那么如何分配呢？
# 答案是使用图像梯度，




img = cv.imread('./pic/1.jpg')
img_gray = cv.cvtColor(img,  cv.COLOR_BGR2GRAY)
sift = cv.xfeatures2d.SIFT_create()
kp = sift.detect(img_gray, None) #函数在图像中找到关键点。如果只想搜索图像的一部分，则可以通过掩码。
img = cv.drawKeypoints(img_gray, kp, img)
cv.imshow('img', img)

cv.waitKey(0)
cv.destroyAllWindows()